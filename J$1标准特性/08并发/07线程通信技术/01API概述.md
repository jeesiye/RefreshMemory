`wait`和`notify`方法概述:  
- `wait`方法会释放当前线程所持有的所有监视器所有权,并进入阻塞/等待状态.  
- `notify/notifyAll`方法,会唤醒同等监视器上等待的所有线程,至于唤醒哪个取决于调度器.  
- 这些操作必须是当前线程,且必须持有监视器的所有权.  
- 个人喜欢使用`wait(long)`方法.  
- `wait(0)`方法会让当前线程一直等待下去,没有时间限制.  

---

`wait`方法释义(翻译整理自API):  
- 先决条件:当前线程必须持有此对象的监视器.(延伸:一般建议在通信的线程内部调用该方法.)  
- 使用方式:通过当前线程的监视器对象实例,来调用`wait`方法.  
- 功能概述:当前的线程通过持有的监视器对象调用`wait`方法,会使得当前线程放弃持有的监视器的所有权,并进入阻塞/等待状态.接触这种状态的条件有以下几种(被唤醒):  
  - 其他线程通过调用当前线程持有的监视器对象的`notify/notifyAll`方法.  
  - 指定`wait`方法的计时参数已经到期.(当参数为0时表示的永久不过期.)  
  - 其他线程尝试中断当前线程,而导致抛出中断异常,引发线程进入死亡状态.  
异常约定:  
  - `IllegalMonitorStateException`:当前线程未持有监视器的所有权,调用该方法抛出.  
  - `IllegalArgumentException`:`wait`接收的参数是个负数,抛出该异常.  
  - `InterruptedException`:当前线程成功执行`wait`方法,并进入阻塞/等待状态,但其他线程却在这个期间尝试中断当前线程,导致抛出中断异常.  

具体规范的描述参见`Object.wait`的API文档,以下是该方法的源码,是个本地方法:  
```java
public final native void wait(long timeout) throws InterruptedException;
```  

---

`notify`方法释义(翻译整理自API):  
- 先决条件:当前线程必须持有此对象的监视器.(延伸:一般建议在通信的线程内部调用该方法)  
- 使用方式:通过当前线程的监视器对象实例,来调用`notify/notifyAll`方法.  
  注意:等待和通知的通信操作必须在同一个监视器对象上.  
- 异常约定:  
  - `IllegalMonitorStateException`:调用该方法的当前线程未持有监视器的所有权时,抛出该异常.  

以下是该方法的源码,也是本地方法的实现:  
```java
public final native void notify();
```  
