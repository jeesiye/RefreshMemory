根据输入输出特性不同,有以下几种约定的接口:  
- `java.io.Closeable`:约定关闭资源功能  
- `java.lang.AutoCloseable`:带有自动关闭资源的触发功能  
- `java.io.Flushable`:约定刷新缓冲区数据  
- `java.lang.Readable`:约定可读标记  
- `java.lang.Appendable`:约定可追加标记  

---

#### 关闭接口  

`java.io.Closeable`:JDK5  
```java
package java.io;
// 该接口指的是源或者目标的数据,是具有关闭的功能的.  
// 这种关闭指的的是释放指定对象所持有的资源,其中的资源比如是打开的某个文件.  
import java.io.IOException;
public interface Closeable extends AutoCloseable {
    // 幂等性
    // (1)调用该方法,将释放所有持有的任何系统资源;  
    // (2)若资源流已经关闭了,再次调用该方法将无效;  
    // (3)一定要确保在程序抛出异常之前,释放掉所持有的物理资源,并在内部将Closeable标记为false;  
    public void close() throws IOException;
}
```  
`java.io.AutoCloseable`:JDK7  
```java
package java.lang;
// 该对象的close()方法,在退出资源块的时候会被自动的调用;以确保异常或错误发生时释放资源.  
// (1)若使用该接口的实现类的流时,是建议使用`try-with-resources`语句的.  
// (2)但是在使用`java.util.Stream`等工具时,若是基于BIO是可以使用的
//    若是基于NIO的话,使用`try-with-resources`是没有必要的.
public interface AutoCloseable {
    // 调用该方法,应当释放所持有的任何底层资源.另此方法在`try-with-resources`语句中会别自动的调用.  
    // (1)关于实现的内部细节:  
    //   在内部的实现细节方面,即使已经释放了底层资源,也应将内部的关闭标记设置为`false`.  
    //   这样可以确保多次调用该方法,不会发生不可预期的错误.
    //   以及在处理包装流的时候,出现的未知错误.  
    // (2)关于实现方法抛出的异常处理:  
    //    a.虽然该方法的约定格式中,抛出的异常类型是`Exception`,但在具体的实现过程中,
    //      还是建议抛出具体的异常类型,不要压制准确的异常类型.  
    //    b.在实现的方法中,是不建议抛出`IntterruptedException`异常的,因为该异常和线程的中断状态交互,
    //      若是实现的方法抛出了该异常,可能会压制正确的触发异常类型.
    // (3)关于该方法的幂等性要求:  
    //    该方法和`java.io.Closeable.close()`方法实现要求不同.
    //    前者不要求实现具有幂等性,后者要求实现具有幂等性.
    //    虽然该方法的实现不要求具有幂等性,但还是要求其实现具有幂等性!
    void close() throws Exception;
}
```  
- 无论是输入流还是输出流,都应当实现该接口的`close()`方法;  
- 关于`AutoCloseable`接口是版本7新增了,衍生出了`try-with-resources`语句;  
- 在版本8中,大多数的流库类都支持`try-with-resources`语句,因为更改了`Closeable`接口;  
- 涉及到NIO的操作,使用`try-with-resurces`是没有必要的;  
- `Closeable`和`AutoCloseable`唯一区别是:前者只能抛出IO异常类型,后者却可以抛出所有的异常类型.  

---

#### 刷新接口

`java.io.Flushable`:JDK5  
- 常理上,针对的是输出流的操作;  
- 约定规范调用该接口的`flush()`方法,将会把缓冲区的字节持久化到目标源中;  
- 操作成功后,应当清空缓冲区的字节;  
- 不是要求所有的输出流类实现该接口的行为;  
- 只有在定义带有缓冲功能的输出流中,才应当实现该接口的方法.  

```java
Compiled from "Flushable.java"
public interface java.io.Flushable {
  public abstract void flush() throws java.io.IOException;
}
```  

---

#### 可读接口

`java.lang.Readable`:JDK5  
- 标记一个可读的字符源;  
- 读取的源头是`java.nio.CharBuffer`处理的;  

```java
Compiled from "Readable.java"
public interface java.lang.Readable {
  public abstract int read(java.nio.CharBuffer) throws java.io.IOException;
}
```

---

#### 追加接口  

`java.lang.Appendable`:JDK5  
- 可以接收字符序列或者是值;  
- 若接收的是格式化的输出,应当是被`java.util.Formatter`处理的;  
- 接收的字符编码应当是UTF-16;  
- 该接口规范的实现不要求是线程安全的;  

```java
Compiled from "Appendable.java"
public interface java.lang.Appendable {
  // 追加字符序列
  public abstract java.lang.Appendable append(java.lang.CharSequence) throws java.io.IOException;
  // 追加字符序列中指定的范围字符
  public abstract java.lang.Appendable append(java.lang.CharSequence, int, int) throws java.io.IOException;
  // 追加一个字符
  public abstract java.lang.Appendable append(char) throws java.io.IOException;
}
```  
