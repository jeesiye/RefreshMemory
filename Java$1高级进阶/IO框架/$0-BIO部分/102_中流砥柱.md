`FileInputStream`结构概览:  
```java
// (1)几乎是所有的输入流的中流砥柱.  
//    在java.io中的包中,大多数输入流的实现类,都是以该类为基础的.  
//    这种结论是不局限于字节输入流和字符输入流.  
// (2)有几种比较特殊功能的输入流,是不一定要依赖该类的实例执行的.  
//    比如管道流,字节数组流等等.  
public class java.io.FileInputStream extends java.io.InputStream {
  // 参数接收的是文件的路径,可以是相对路径也可以是绝对路径.(相对路径默认是从$user.dir加载的)
  // 内部实际调用的是本地重载的构造器FileInputStream(File file)方法.
  public java.io.FileInputStream(java.lang.String) throws java.io.FileNotFoundException;
  // 接收File的实例,构建实例.
  public java.io.FileInputStream(java.io.File) throws java.io.FileNotFoundException;
  // 接收FileDescriptor实例,构建实例.
  public java.io.FileInputStream(java.io.FileDescriptor);
  // 用了本地方法实现,参照openjdk中jdk8的源码,调用的是readSingle函数.  
  public int read() throws java.io.IOException;
  // 以下两个方法,使用的是本地方法的实现,而非是InputStream中定义的具体方法
  // 参照openjdk中jdk8的源码,调用的readBytes函数.  
  public int read(byte[]) throws java.io.IOException;
  public int read(byte[], int, int) throws java.io.IOException;
  // 使用本地方法skip0(long)实现,跳过指定的字节.
  public long skip(long) throws java.io.IOException;
  // 使用本地方法available0()实现,返回当前可读取的字节总数.  
  public int available() throws java.io.IOException;
  // 关闭关联的所有资源流.
  public void close() throws java.io.IOException;
  // 获取聚合的FileDescriptor实例.
  public final java.io.FileDescriptor getFD() throws java.io.IOException;
  // 获取当前对象聚合的FileChannel实例.
  public java.nio.channels.FileChannel getChannel();
}
```  

`FileInputStream`基本使用示例:  
较为常用的方法有`read`,`close`,`available`和`skip`方法.  
`$user.dir`目录下的有文件`files`,内容为:`abc\n123\n`  
- 创建`FileInputStream`的实例:  
  ```java
  FileInputStream string = new FileInputStream("files");
  System.out.println(string.available());// out:8
  FileInputStream file = new FileInputStream(new File("files"));
  System.out.println(file.available());// out:8
  FileInputStream fd = new FileInputStream(FileDescriptor.in);
  System.out.println(fd.available());// out:0
  ```  
- 读取字节`read`三个重载方法的使用:  
  ```java
  byte[] arr = new byte[24];
  FileInputStream in = new FileInputStream("files");
  int read = in.read();
  System.out.println(read);// out:97
  int size = in.read(arr);
  System.out.println(size);// out:7
  int limit = in.read(arr, 10, 10);
  System.out.println(limit);// out:-1
  System.out.println(Arrays.toString(arr));
  // [98, 99, 10, 49, 50, 51, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  // 其中的10在编码表中表示的是换行符号
  ```  
- 跳过读取字节小标的方法`skip`:  
  ```java
  FileInputStream in = new FileInputStream("files");
  in.skip(6);
  System.out.println(in.read());// out:51
  System.out.println(in.read());// out:10
  System.out.println(in.read());// out:-1
  ```  

---

`FileOutputStream`结构概览:  
```java
// (1)几乎是所有输出流的中流砥柱!
//    在java.io包中,大多数的输出流的实现类,都是以该类为基础的.
//    这种结论,是不局限于输出字节流和字符流的.
// (2)也是有几种输出流是不属于这种结论的范畴的.  
//    比较管道流,以及字节数组缓冲流等等.  
public class java.io.FileOutputStream extends java.io.OutputStream {
  // 在构造器中,本质上是接收两种类型的参数的,一个是File,一个是FileDecriptor.
  // (1)参数String类型说明
  // 至于接收的String类型,指的是文件的路径,内部还会借此构建File的实例.
  // (2)参数boolean类型说明(默认是false)
  // 至于布尔参数boolean,表示的是:是否对该文件采取追加的模式进行写入字节.  
  public java.io.FileOutputStream(java.lang.String) throws java.io.FileNotFoundException;
  public java.io.FileOutputStream(java.lang.String, boolean) throws java.io.FileNotFoundException;
  public java.io.FileOutputStream(java.io.File) throws java.io.FileNotFoundException;
  public java.io.FileOutputStream(java.io.File, boolean) throws java.io.FileNotFoundException;
  public java.io.FileOutputStream(java.io.FileDescriptor);
  // 调用的是本地方法的实现.
  // 参照openjdk中jdk8的源码,调用的是writeSingle函数.
  public void write(int) throws java.io.IOException;
  // 注意,涉及数组的输出操作,未按照OutputStream中的规范的具体方法.
  // 参照openjdk-jdk8,调用的是writeBytes函数.  
  public void write(byte[]) throws java.io.IOException;
  public void write(byte[], int, int) throws java.io.IOException;
  // 关闭所有关联的资源
  public void close() throws java.io.IOException;
  // 获取聚合的FileDescriptor实例.
  public final java.io.FileDescriptor getFD() throws java.io.IOException;
  // 获取聚合的FileChannel的实例.
  public java.nio.channels.FileChannel getChannel();
}
```  

`FileOutputStream`中常用的方法就`write`和`close`方法.  
过于简单,不予赘述.  
