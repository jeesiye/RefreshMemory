+-------------------------------------------------------------------------+
|                              属性表集合
+-------------------------------------------------------------------------+

属性表的存在位置?
  (1) ClassFile
  (2) filed_info
  (3) method_info
  (4) Code_attribute

属性表的注意事项?
  (1) 属性名称必须具有唯一性;
  (2) 用户可自定义添加属性到属性表中;
  (3) 各属性表的排序不是严格约束的;
  (4) jvm会自动忽略掉无法识别的属性;

属性表的通用格式
attribute_info{
    u2  attribute_name_index;  // 1)指示常量池中有效的索引;  2)必须是Class_Utf8_info结构;
    u4  attribute_length;  // 指示其后跟随的信息字节的长度(即占用多个字节);
    u1  info[attribute_length];  // 受attribute_length的约束
}

预置属性的三种分类(jvms8)?
    1. 对Java虚拟机正确解读class文件起到关键作用的5个属性:
        (1) ConstantValue
        (2) Code
        (3) StackMapTable
        (4) Exceptions
        (5) BootstrapMethods
    2. 对JavaSE平台的类库正确解读class文件起到关键作用的12个属性;
        (1)   InnerClasses
        (2)   EnclosingMethod
        (3)   Synthetic
        (4)   Signature
        (5)   RuntimeVisibleAnnotations
        (6)   RuntimeInvisibleAnnotations
        (7)   RuntimeVisibleParameterAnnotations
        (8)   RuntimeInvisibleParameterAnnotations
        (9)   RuntimeVisibleTypeAnnotations
        (10)  RuntimeInvisibleTypeAnnotations
        (11)  AnnotationDefault
        (12)  MethodParameters
    3. 对Java虚拟机或JavaSE平台类库能够正确解读class文件虽然不起关键作用,但却可以作为使用工具来使用的6个属性:
        (1) SourceFile
        (2) SourceDebugExtension
        (3) LineNumberTable
        (4) LocalVariableTable
        (5) LocalVariableTypeTable
        (6) Deprecated


+-------------------------------------------------------------------------+
|             预置属性表概览(jvms8/按属性应该出现的位置排序)
+-------------------------------------------------------------------------+

-----------------------------------------------------------------------------------------------------------------
编号 |   属性名                                       |        位置                              |   class文件(版本)
-----------------------------------------------------------------------------------------------------------------
1       SourceFile                                     ClassFile                                      45.3
2       InnerClasses                                   ClassFile                                      45.3
3       EnclosingMethod                                ClassFile                                      49.0
4       SourceDebugExtension                           ClassFile                                      49.0
5       BootstrapMethods                               ClassFile                                      51.0
6       ConstantValue                                  field_info                                     45.3
7       Code                                           method_info                                    45.3
8       Exceptions                                     method_info                                    45.3
9       RuntimmeVisibleParameterAnnotations            method_info                                    49.0
10      \+ RuntimeInvisibleParameterAnnotations        method_info                                    49.0
11      AnnotationDefault                              method_info                                    49.0
12      MethodParameters                               method_info                                    52.0
13      Synthetic                                      ClassFile + field_info + method_info           45.3
14      Deprecated                                     ClassFile + field_info + method_info           45.3
15      Signature                                      ClassFile + field_info + method_info           49.0
16      RuntimeVisibleAnnotations                      ClassFile + field_info + method_info           49.0
17      \+ RuntimeInvisibleAnnotations                 ClassFile + field_info + method_info           49.0
18      LineNumberTable                                Code                                           45.3
19      LocalVariableTable                             Code                                           45.3
20      LocalVariableTypeTable                         Code                                           49.0
21      StackMapTable                                  Code                                           50.0
22      RuntimeVisibleTypeAnnotations                  ClassFile + field_info + method_info           52.0
23      \+ RuntimeInvisibleTypeAnnotations             ClassFile + field_info + method_info           52.0
-----------------------------------------------------------------------------------------------------------------



+-------------------------------------------------------------------------+
|                         (1) SourceFile属性表
+-------------------------------------------------------------------------+
SourceFile_attribute{
    u2  attribute_name_index;  // 1)指示常量池中有效的索引;2)必须是CONSTANT_Utf8_info结构;3)值必须是`SourceFile`;
    u4  attribute_length;  // 该项的值必须是2!
    u2  sourcefile_index;  // 1)指示常量池中有效的索引;2)必须是CONSTANT_Utf8_info结构,以表示字符串;
}
注意事项:
    (1) 可选的定长属性;
    (2) 位于ClassFile结构的属性表中;
    (3) 一个ClassFile结构的属性表中最多只能包含一个SourceFile属性;



+-------------------------------------------------------------------------+
|                         (2) InnerClasses属性表
+-------------------------------------------------------------------------+
InnerClasses_attribute{
    u2  attribute_name_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Utf8_info结构;3)值必须是`InnerClasses`;
    u4  attribute_length;  // 1)标记当前属性的长度;2)不包括之前的u2和本身的u4,即后续占用的字节长度;
    u2  number_of_classes;  // 指示后续的classes[]数组的数量;
    {  u2  inner_class_info_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Class_info结构;
       u2  outer_class_info_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Class_info结构;3)如果C不是内部类,局部类,匿名类,那么该值为0;
       u2  inner_class_name_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Utf8_info结构;3)若C是匿名类,该值必须是0;
       u2  inner_class_access_flags;  // 内部类的访问标志,类似于ClassFile中的访问标志
    } classes[number_of_classes] // 指示内部类的数组classes[]
}

inner_class_access_flags候选表(计算方式和ClassFile中的access_flags类似)
----------------------------------------------------------------------------------
  标志                |      值        |           含义
----------------------------------------------------------------------------------
  ACC_PUBLIC              0x0001          标志为public修饰符,或者默认就是该修饰符;
  ACC_PROTECTED           0x0002          标志为protected修饰符;
  ACC_PRIVATE             0x0004          标志为private修饰符;
  ACC_STATIC              0x0008          标志为static修饰符,或者默认就是该修饰符;
  ACC_FINAL               0x0010          标志为final修饰符;
  ACC_INTERFACE           0x0200          标志为interface,表示接口
  ACC_ABSTRACT            0x0400          标志为abstract修饰符,或者默认就是该修饰符;
  ACC_SYNTHETIC           0x1000          标志由编译器生成,意味着源文件中没有该类型;
  ACC_ANNOTATION          0x2000          标志annotation,是个注解;
  ACC_ENUM                0x4000          标志enum,是个枚举类;
----------------------------------------------------------------------------------

标记补充C?
  C表示一个类或接口的class格式;

注意事项:
    (1) 可选的变长属性;
    (2) 位于ClassFile结构的属性表中;
    (3) ClassFile结构中只能有0个或1个InnerClasses属性!



+-------------------------------------------------------------------------+
|                        (3) EnclosingMethod属性表
+-------------------------------------------------------------------------+
EnclosingMethod_attribute{
    u2  attribute_name_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Utf8_info结构;3)该值必须是`EnclosingMethod`;
    u4  attribute_length;  // 该值必须为4!
    u2  class_index;  // 1)指示当前类中声明的最内层类;2)指示常量池的有效索引;3)必须是CONSTANT_Class_info结构;
    u2  method_index;  // 1)指示常量池中有效的索引;2)必须是CONSTANT_NameAndType_info结构;3)指示由class_index引用类对应的方法名和方法类型;
}

注意事项?
    (1) 可选的定长属性;
    (2) 位于ClassFile结构的属性表中;
    (3) 当且仅当class是局部类或匿名类时,才能具有EnclosingMethod属性;

关于method_index项的特殊情况?
    (1) 考虑源代码中的局部类和匿名类情况,这种情况,当前类的源代码直接处于实例初始化器或静态实例初始化器中;
    (2) 考虑源代码中声明字段赋值匿名类的情况,这种情况,当前类的源代码直接实例变量初始化器或类变量初始化器中;
    (3) 以上两种分类,可概述为:
            若当前类直接包含在某个方法,构造器,表达式中,那么method_index的值必须是0!



+-------------------------------------------------------------------------+
|                    (4) SourceDebugExtension属性表
+-------------------------------------------------------------------------+
SourceDebugExtension_attribute{
    u2  attribute_name_index;  // 1)指示常量池中有效的索引;2)必须是CONSTANT_Utf8_info结构;3)值必须是`SourceDebugExtension`;
    u4  attribute_length;  // 2)指示当前属性的长度,不包含之前的u2和本身的u4;
    u2  debug_extension[attribute_length];  // 1)用于保存扩展的调试信息;2)用的是改进版的UTF8的字符串表示;
}

注意事项?
    (1) 可选的变长属性;
    (2) 位于ClassFile结构的属性表中;
    (3) 该属性在ClassFile结构中只能有0个或者1个;



+-------------------------------------------------------------------------+
|                        (5) BootstrapMethods属性表
+-------------------------------------------------------------------------+
BootstrapMethods_attribute {
    u2  attribute_name_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Utf8_info结构;3)值必须是`BootstrapMethods`;
    u4  attribute_length;  // 指示当前属性的长度,不包含之前的u2和本身的u4;
    u2  num_bootstrap_methods;  // 指示bootstrap_methods[]数组的长度;
    {  u2  bootstrap_method_ref;  // 1)指示常量池的有效索引;2)必须是CONSTANT_MethodHandle_info结构;
       u2  num_bootstrap_arguments;  // 指示bootstrap_arguments[]数组的长度;
       u2  bootstrap_arguments[num_bootstrap_arguments];  // 1)指示常量池的有效索引;2)必须是以下常量类型之一(Tag标志):3,4,5,6,7,8,15,16
    } bootstrap_methods[num_bootstrap_methods];  // 1)该数组中的元素,指示了引导方法(方法句柄)和引导序列;2)引导序列中的元素指示了引导方法中的静态参数;
}

注意事项?
    (1) 可选的变长属性;
    (2) 若ClassFile中的常量池有至少一个CONSTANT_InvokeDynamic_info结构,那么ClassFile的属性表集合中有且仅有一个BootstrapMethods属性表;
    (3) 该属性表,用于保存由invokedynamic指令引用的引导方法限定符;

方法句柄?
    (1) 方法句柄的形式,由invokdynamic指令中调用点限定符的持续解析过程来决定.
          java.lang.invoke.MethodHandle#invoke函数在执行的时候,要求引导方法的句柄必须能按照实际传入的参数作出调整,
          就好似通过java.lang.invoke.MethodHandle#asType函数调用一般.
    (2) 而与之对应的CONSTANT_MethodHandle_info的结构中的项也是限制的.
          reference_kind项的值应当是6或者8;
          reference_index项指向的索引应当是静态方法或构造器;
            它接受的参数类型应当依次是如下三种参数:
              a) java.lang.invoke.MethodHandles.Lookup;
              b) java.lang.String;
              c) java.lang.invoke.MethodType;
    (3) 如果不符合上述的要求,那么在调用点限定符的解析过程中,对引导方法句柄的调用就会失败.



+-------------------------------------------------------------------------+
|                        (6) ConstantValue属性表
+-------------------------------------------------------------------------+
ConstantValue_attribute {
    u2  attribute_name_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Utf8_info结构;3)值必须是`ConstantValue`;
    u4  attribute_length;  // 该值固定是2;
    u2  constantvalue_index;  // 1)指示常量池的有效索引;2)常量池中的项必须适应当前字段类型
}

ConstantValue属性的类型(参考表)
---------------------------------------------------------------------------------------------------
  当前常量值的类型                            |             对应常量池中的项的常量类型
---------------------------------------------------------------------------------------------------
  long                                                    CONSTANT_Long
  float                                                   CONSTANT_Float
  double                                                  CONSTANT_Double
  byte,short,int,char,boolean                             CONSTANT_Integer
  String                                                  CONSTANT_String
---------------------------------------------------------------------------------------------------

注意事项?
    (1) 该属性表示一个常量表达式的值;
    (2) 是可选的定长属性;
    (3) 位于filed_info结构的属性表中;
    (4) 若在filed_info结构中表示的非静态字段包含了ConstantValue属性,那么该属性必须要被jvm忽略!

ConstantValue属性表的用法?
    (1) 如果该字段是静态字段,也就是说field_info结构中的access_flags项设置了ACC_STATIC标志;
    (2) 那么field_info结构所表示的字段,其值将是它的项ConstantValue属性所表示的值;
    (3) 这个过程是该字段所在的类或接口初始化阶段的一部分,也就是在类或接口初始化方法之前执行的;



+-------------------------------------------------------------------------+
|                            (7) Code属性表
+-------------------------------------------------------------------------+
Code_attribute {
    u2  attribute_name_index;  // 1)指示常量池的有效索引;2)必须是CONSTANT_Utf8_info结构;3)值必须是`Code`;
    u4  attribute_length;  // 指示当前属性的长度,不包含之前的u2和本身的u4;
    u2  max_stack;  // 指示当前方法的操作数栈,在方法执行的任何时间点的最大深度;
    u2  max_locals;  // 1)指示当前方法引用的局部变量表中的局部变量个数;2)包含调用此方法时用于传递参数的局部变量;
    u4  code_length;  // 1)指示当前方法的code[]数组的长度;2)该值必须大于0;3)当前方法的code[]数组不能为空;
    u1  code[code_length];  // 指示实现当前方法的jvm代码的实际字节内容;
    u2  exception_table_length;
    {  u2 start_pc;
       u2 end_pc;
       u2 handler_pc;
       u2 catch_type;
    } exception_table[exception_table_length];
    u2  attributes_count;
    attribute_info  attributes[attributes_count];
}

表中项解释的补充?
    1. max_locals项的特殊情况?
        (1) long和double类型的局部变量的最大索引是max_locals-2;
        (2) 其他类型的局部变量的最大索引是max_locals-1;



+-------------------------------------------------------------------------+
+-------------------------------------------------------------------------+
