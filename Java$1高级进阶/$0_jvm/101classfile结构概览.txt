+-------------------------------------------------+
|  class文件的组成部分
+-------------------------------------------------+

组成class文件的基本类型?
  (1)class文件=无符号数+表
  (2)表=无符号数和可能的表
  (3)classfile=unsigned_number+table(unsigned_number[,table])
  (4)无符号数在这里用u1,u2,u4,u8表示;

class文件的10种组成类型:
  (1)魔数和版本
  (2)常量池
  (3)类,父类,接口集合;
  (4)字段,方法,属性集合;

class文件的严格分类
classfile{
    u4                  magic;
    u2                  minor_version;
    u2                  major_version;
    u2                  constant_pool_count;
    cp_info             constant_pool[constant_pool_count-1];
    u2                  access_flags;
    u2                  this_class;
    u2                  super_class;
    u2                  interfaces_count;
    u2                  interfaces[interfaces_count];
    u2                  fields_count;
    field_info          fileds[fileds_count];
    u2                  methods_count;
    method_info         methods[methods_count];
    u2                  attributes_count;
    attribute_info      attributes[attributes_count];
}



+-------------------------------------------------+
| 魔数magic
+-------------------------------------------------+
固定形式: 0xCAFFBABE


+-------------------------------------------------+
| 版本minor_version+major_version
+-------------------------------------------------+
u2 minor_version;   表示次版本
u2 major_version;   表示主版本
    (1)次版本的范围是0~65535;
    (2)主版本从45开始(JDK1);
    (3)参考javac指令的`-target`和`-source`指令;


+-------------------------------------------------+
| 常量池constant_pool
+-------------------------------------------------+

常量池的基本类型?
  (1)字面量(Literal)和符号引用(Symbolic References);
  (2)字面量有:utf8编码,整型,单精度,长整型,双精度,字符串;
  (3)符号引用有:类或接口,字段,方法,接口方法,字段或方法的部分;

常量池的计数为什么从1开始?
  (1)特定的情况;
  (2)某些指向常量池的索引值的数据,不再需要引用常量池的项目;
  (3)把这个索引值置位为0来表示;


什么是标志位tag?
  (1)u1类型的标志位;
  (2)指示常量的类型;
  (3)JDK7之前有11种常量类型;
  (4)JDK7开始新增3种,总计15种常量类型;
  (5)在常量池中它们出现的顺序是没有规律的;

常量类型中的项(item)占用字节数的类型规律?
  (1) tag的类型始终为u1;代表具体的常量类型;
  (2) index的类型始终为u2;指示常量池的索引值;
  (3) length的类型为u2;指示占用的字节个数;
        1) 常量的类型中只有CONSTANT_Utf8中的项存在length;
        2) 其占用字节数类型是u2;
  (4) bytes的类型不固定;指示占用多少个字节;
        1) CONSTANT_Utf8中的bytes是u1;具体值受其中的项length约束;
        2) CONSTANT_Integer和CONSTANT_Float中的bytes是u4;
        3) CONSTANT_Long和CONSTANT_Double中的bytes是u8;

常量类型的标志位的助记规律?
  (1)1
  (2)3~12
  (3)15,16,18


15种常量分类(classify)及其标志位(tag)
Constant Pool Tag_And_Classify{
    u1[1]  CONSTANT_Utf8;  // utf8编码的字符串
    u1[3]  CONSTANT_Integer;  // 整型字面量
    u1[4]  CONSTANT_Float;  // 单精度字面量
    u1[5]  CONSTANT_Long;  // 长整型字面量
    u1[6]  CONSTANT_Double;  // 双精度字面量
    u1[7]  CONSTANT_Class;  // 类或接口的符号引用
    u1[8]  CONSTANT_String;  // 字符串的字面量
    u1[9]  CONSTANT_Fieldref;  // 字段的符号引用
    u1[10] CONSTANT_Methodref;  // 方法的符号引用
    u1[11] CONSTANT_InterfaceMethodref;  // 接口方法的符号引用
    u1[12] CONSTANT_NameAndType;  // 字段或方法的部分的符号引用
    u1[15] CONSTANT_MethodHandle;  // 方法句柄;
    u1[16] CONSTANT_MethodType;  // 方法类型
    u1[18] CONSTANT_InvokeDynamic;  // 动态方法的调用点
}


15种常量类型的结构
Constant Pool Classify{
    CONSTANT_Utf8_info{
        u1  tag;  // 指示utf8编码的字符串(CONSTANT_Utf8),标志位是1;
        u2  length;  // 指示字符串占用的字节个数;
        u1  bytes;  // 指示有多少个字节,受length约束;(由此字符串最大占用65535个字节,约等64K)
    }
    CONSTANT_Integer_info{
        u1  tag;  // 指示整型字面量(CONSTANT_Integer),标志位是3;
        u4  bytes;  // 高位在前存储的int值;
    }
    CONSTANT_Float_info{
        u1  tag;  // 指示单精度字面量(CONSTANT_Float),标志位是4;
        u4  bytes;  // 高位在前存储的float值;
    }
    CONSTANT_Long_info{
        u1  tag;  // 指示长整型的字面量(CONSTANT_Long),标志位是5;
        u8  bytes;  // 高位在前存储的long值;
    }
    CONSTANT_Double_info{
        u1  tag;  // 指示双精度的字面量(CONSTANT_Double),标志位是6;
        u8  bytes;  // 高位在前存储的double值;
    }
    CONSTANT_Class_info{
        u1  tag;  // 指示类或接口的符号引用(CONSTANT_Class),标志位是7;
        u2  index;  // 指示常量池中项的索引值;
    }
    CONSTANT_String_info{
        u1  tag;  // 指示字符串字面量的符号引用(CONSTANT_String),标志位是8;
        u2  index;  // 指示常量池中项的索引值;
    }
    CONSTANT_Fieldref_info{
        u1  tag;  // 指示字段的符号引用(CONSTANT_Fieldref),标志位是9;
        u2  index;  // 指示常量池中项的索引值,通常指向CONSTANT_Class_info;
        u2  index;  // 指示常量池中项的索引值,通常指向CONSTANT_NameAndType_info;
    }
    CONSTANT_Methodref_info{
        u1  tag;  // 指示方法的符号引用(CONSTANT_Methodref),标志位是10;
        u2  index;  // 指示常量池中项的索引值,通常指向CONSTANT_Class_info;
        u2  index;  // 指示常量池中项的索引值,通常指向CONSTANT_NameAndType_info;
    }
    CONSTANT_InterfaceMethodref_info{
        u1  tag;  // 指示接口方法的符号引用(CONSTANT_InterfaceMethodref),标志位是11;
        u2  index;  // 指示常量池中项的索引值,通常指向CONSTANT_Class_info;
        u2  index;  // 指示常量池中项的索引值,通常指向CONSTANT_NameAndType_info;
    }
    CONSTANT_NameAndType_info{
        u1  tag;  // 指示字段或方法的部分符号引用(CONSTANT_NameAndType_info),标志位是12;
        u2  index;  // 指示常量池中项的索引值,表示的是字段或方法的名称常量;(多次测试,类型为CONSTANT_Utf8_info,不保证)
        u2  index;  // 指示常量池中项的索引值,表示的是字段或方法的描述符常量;(多次测试,类型为CONSTANT_Utf8_info,不保证)
    }
    CONSTANT_MethodHandle_info{
        u1  tag;  // 指示方法句柄(CONSTANT_MethodHandle),标志位是15;[JDK7]
        u1  reference_kind;  // 取值的范围有限定; 1 <= x <= 9
        u2  reference_index;  // 必须是常量池中有效的索引值;
    }
    CONSTANT_MethodType_info{
        u1  tag;  // 指示方法类型(CONSTANT_MethodType),标志位是16;[JDK7]
        u2  descriptor_index;  // 1)必须是常量池中的有效索引值;  2)必须是常量类型CONSTANT_Utf8;
    }
    CONSTANT_InvokeDynamic_info{
        u1  tag;  // 指示动态方法的调用点(CONSTANT_InvokeDynamic),表示为是18;[JDK7]
        u2  bootstrap_method_attr_index;  // 必须是当前class文件中引导方法表的bootstrap_methods[]数组的有效引用;
        u2  name_and_type_index;  // 1)必须是常量池中的有效索引值;  2)必须是常量类型CONSTANT_NameAndType;
    }
}



+-------------------------------------------------+
| 访问标志access_flags
+-------------------------------------------------+

前提概述:
  (1)访问标志仅存储在u2个无符号数中,进行反运算比较麻烦;
        有两种方式进行验证:
        a) 结合工具javap和hexdump进行验证;
        b) 根据源文件和访问标志表进行推测,然后比较结果;
  (2)运算的方式,是二进制的或运算,符号是`|`;
        比如有类:public class App{};
        推测访问标志是ACC_SUPER(0x0020)和ACC_PUBLIC(0x0001);
        0x0001 | 0x0020 = 0x0021;
        然后比较十六进制的字节码文件,验证是正确的;

访问标志表:
标志名称                hex值        含义
ACC_PUBLIC             0x0001      标记public修饰
ACC_FINAL              0x0010      标记final修饰
ACC_SUPER              0x0020      是否使用invokespecial指令的新语义(JDK1.0.2开始强制的)
ACC_INTERFACE          0x0200      标记接口修饰
ACC_ABSTRACT           0x0400      标记抽象修饰(抽象类和接口此值必须为真)
ACC_SYNTHETIC          0x1000      标记代码不是由用户代码产生的
ACC_ANNOTATION         0x2000      标记注解修饰
ACC_ENUM               0x4000      标记枚举修饰




+-------------------------------------------------+
| 类索引,父类索引,接口索引集合
+-------------------------------------------------+

java.lang.Object的父类索引?
  (1)Object的父类索引是不存在的,因为它是所有类的超类;
  (2)Object的super_class的索引值为0;

类索引和父类索引的结构
this_class
    u2  index; // 1)指示常量池中有效的索引值  2)必须是CONSTANT_Class_info结构;

super_class
    u2  index; // 1)指示常量池中有效的索引值  2)必须是CONSTANT_Class_info结构;

接口索引集合的结构
interfaces_count
    u2  bytes; // 指示接口索引的个数;
interface[count]
    u2  index; // 1)指示常量池中有效的索引值;  2)必须是CONTANT_Class_info结构;
    ...

接口索引的注意事项:
  (1)接口的索引区别于常量池的索引,是从0开始计数的;
  (2)接口索引的个数是 count-1 个;


+-------------------------------------------------+
|  属性集合
+-------------------------------------------------+
