
对于`java.io.InputStream`和`java.io.OutputStream`中的方法,
只有`read(int b)`和`write(int b)`是抽象方法,其他的不是空实现,
`java.io.InputStream`和`java.io.OutputStream`概述:  
- `read(int b)`和`write(int b)`是抽象方法,实现类的实现方式大多数是通过本地方法的途径;  
- 其他的方法要么是空方法,要么是调用本地重载的方法;  
- 重点是读写的操作都是以字节`byte`为基础的,即使返回的类型是int.

---

`java.io.InputStream`结构概览:  
```java
Compiled from "InputStream.java"
public abstract class java.io.InputStream implements java.io.Closeable {
  private static final int MAX_SKIP_BUFFER_SIZE;
  public java.io.InputStream();
  public abstract int read() throws java.io.IOException;
  public int read(byte[]) throws java.io.IOException;
  public int read(byte[], int, int) throws java.io.IOException;
  public long skip(long) throws java.io.IOException;
  public int available() throws java.io.IOException;
  public void close() throws java.io.IOException;
  public synchronized void mark(int);
  public synchronized void reset() throws java.io.IOException;
  public boolean markSupported();
}
```  

#### 部分概念概述:  
超级类`InputStream`概述:  
- 标记的是个抽象类,但是其中的方法只有无参的`read()`方法是抽象的.  
  至于其他的方法,不要求具体的输入流都具备约定功能,根据流的定性而选择的实现.  
- 该接口规范输入流应当至少具有如下的功能:  
  - 读取字节的功能,用`read`方法表示;  
  - 跳过流下标的功能,用`skip`方法表示;  
  - 标记流下表的功能,用`mark`方法表示;  
  - 重置回归跳过前流下标的功能,用`reset`方法表示;  
  - 关闭资源流的功能,用`close`方法表示;  
  - 属性查询的功能,查询可读取的字节用`available`方法表示,查询是否支持标记用`markSupported`方法表示;  
- 部分方法总结:  
  - 对于`read`方法的实现,应当采取阻塞读取的策略,符合BIO的定性;  
  - 对于`close`方法的实现,在关闭处理的过程中,应当实现为联动关闭.(涉及包装流的场景)  
  - 对于`skip`方法,本类中实现细节没有查看意义,各个具体的子类都重写了该方法.(个人观点)  

静态属性`MAX_SKIP_BUFFER_SIZE`概述:  
- 该属性规定的是允许`skip`方法跳过的最大字节数量,为2048;  
- 1bit=1b,2048bits=2k.  

抽象方法`read()`概述:  
- doc规范中约定该方法的实现应当采取阻塞读取的方式;  
- 读取的是单个字节,返回值的范围是`0~255`,但返回类型是`int`类型;  
- 若读取到流末尾,没有字节可读了,就返回`-1`;  



具体方法`skip(long)`概述:
- 不做讨论,详细的查看具体子类的重写实现逻辑;  
- 至于超级接口的实现逻辑,个人暂不知目的性;  

方法`mark`,`markSupport`,`reset`,`available`,`close`:  
- 采取的都是空方法的实现,涉及到返回值,返回的都是默认值;  
- 值得注意的是`mark`方法标记为`synchronized`方法,但要知道sync是没有继承性的.  
- 至于`close`方法的具体实现,应当遵循顶层接口的约定;  

#### 重载`read`方法源码阅读:  
`read(byte[], int, int)`方法:  
```java
// 概述:
// (1)对接收的三个参数进行合法性的校验
// (2)循环调用本地重载的read方法,以是否返回-1作为结束的阀值;  
// (3)返回的值,不一定是len,但会小于等于len.
// 参数的概述:
// b[] 接收读取字节的容器
// off 存储到b[]中的开始下标
// len 计划读取多少个字节,若没有可读取的字节,读取的字节长度就是返回值
// 返回值概述:
// 返回的值是内部定义的本地变量i.表示成功读取多少个字节.也可能返回-1.
public int read(byte b[], int off, int len) throws IOException {
    // step1:合法性校验
    // 1.1 判断byte数组参数b是否为null,若是抛出空指针异常.
    if (b == null) {
        throw new NullPointerException();
    // 1.2 判断off,len参数不能为负数,以及要读取的数组不能大于可读取的数组长度,
    // 否则抛出下标越界异常.  
    } else if (off < 0 || len < 0 || len > b.length - off) {
        throw new IndexOutOfBoundsException();
    // 1.3 检查len的参数是否为0,若是直接返回0.
    // 此处的0表示的是读取的字节数量,即表示没有读取字节.  
    } else if (len == 0) {
        return 0;
    }

    // step2:校验通过后,开始按照要求读取字节数组.
    // 2.1 先读取一个字节,赋值给本地int变量c.
    //    判断c是否为-1,若是直接返回-1,表示当前流中没有可读取的字节.
    int c = read();
    if (c == -1) {
        return -1;
    }
    // 2.2 若读取字节c不是负数,则将其赋值给b[off]  
    //    接收的参数b[]表示接收读取字节的容器;
    //    接收的off,表示接收的开始下标,len表示要读取的长度
    b[off] = (byte)c;
    // 2.3 定义本地变量,初始为1,表示读取的字节数量.
    int i = 1;
    try {
        // 开始循环读取,阀值是参数len,读取成功一次,i+1
        for (; i < len ; i++) {
            c = read();
            // 若读取失败,结束循环
            if (c == -1) {
                break;
            }
            // 读取成功,存储读取的字节
            b[off + i] = (byte)c;
        }
    } catch (IOException ee) {
    }
    // 2.4 返回读取本地变量i
    return i;
}
```  

#### `read(byte[])`方法源码阅读:  
```java
// 内部调用了重载的方法read(byte b[],int off,int len)
// 不过传递的参数off是0值.
public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
}
```

---

`java.io.OutputStream`结构概览:
```java
Compiled from "OutputStream.java"
public abstract class java.io.OutputStream implements java.io.Closeable,java.io.Flushable {
  public java.io.OutputStream();
  public abstract void write(int) throws java.io.IOException;
  public void write(byte[]) throws java.io.IOException;
  public void write(byte[], int, int) throws java.io.IOException;
  public void flush() throws java.io.IOException;
  public void close() throws java.io.IOException;
}
```  

`OutputStream`解析和部分源码阅读:  
```java
package java.io;
public abstract class OutputStream implements Closeable, Flushable {
    // 抽象方法,大多数的实现类是通过本地方法实现的
    public abstract void write(int b) throws IOException;
    // 调用本地重载的write(byte b[],int off,int len)方法
    public void write(byte b[]) throws IOException {
        write(b, 0, b.length);
    }
    public void write(byte b[], int off, int len) throws IOException {
        // step1:对参数的合法性校验
        if (b == null) {
            // b不能为null,否则抛出空指针异常
            throw new NullPointerException();
        } else if ((off < 0) || (off > b.length) || (len < 0) ||
                   ((off + len) > b.length) || ((off + len) < 0)) {
            // off和len的合法逻辑限制,违反抛出下标越界异常
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return;
        }
        // 单个字节写入,调用本地重载的方法write(int b)
        // 循环写入
        for (int i = 0 ; i < len ; i++) {
            write(b[off + i]);
        }
    }
    // 约定空方法,实现类可选择性的重写
    public void flush() throws IOException {
    }
    // 约定空方法,实现类可选择性重写
    public void close() throws IOException {
    }
}
```  
