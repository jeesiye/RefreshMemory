`java.io.InputStream`结构概览:  
```java
Compiled from "InputStream.java"
public abstract class java.io.InputStream implements java.io.Closeable {
  private static final int MAX_SKIP_BUFFER_SIZE;
  public java.io.InputStream();
  public abstract int read() throws java.io.IOException;
  public int read(byte[]) throws java.io.IOException;
  public int read(byte[], int, int) throws java.io.IOException;
  public long skip(long) throws java.io.IOException;
  public int available() throws java.io.IOException;
  public void close() throws java.io.IOException;
  public synchronized void mark(int);
  public synchronized void reset() throws java.io.IOException;
  public boolean markSupported();
}
```  

#### 部分概念概述:  
超级类`InputStream`概述:  
- 标记的是个抽象类,但是其中的方法只有无参的`read()`方法是抽象的.  
  至于其他的方法,不要求具体的输入流都具备约定功能,根据流的定性而选择的实现.  
- 该接口规范输入流应当至少具有如下的功能:  
  - 读取字节的功能,用`read`方法表示;  
  - 跳过流下标的功能,用`skip`方法表示;  
  - 标记流下表的功能,用`mark`方法表示;  
  - 重置回归跳过前流下标的功能,用`reset`方法表示;  
  - 关闭资源流的功能,用`close`方法表示;  
  - 属性查询的功能,查询可读取的字节用`available`方法表示,查询是否支持标记用`markSupported`方法表示;  
- 部分方法总结:  
  - 对于`read`方法的实现,应当采取阻塞读取的策略,符合BIO的定性;  
  - 对于`close`方法的实现,在关闭处理的过程中,应当实现为联动关闭.(涉及包装流的场景)  
  - 对于`skip`方法,本类中实现细节没有查看意义,各个具体的子类都重写了该方法.(个人观点)  

静态属性`MAX_SKIP_BUFFER_SIZE`概述:  
- 该属性规定的是允许`skip`方法跳过的最大字节数量,为2048;  
- 1bit=1b,2048bits=2k.  

抽象方法`read()`概述:  
- doc规范中约定该方法的实现应当采取阻塞读取的方式;  
- 读取的是单个字节,返回值的范围是`0~255`,但返回类型是`int`类型;  
- 若读取到流末尾,没有字节可读了,就返回`-1`;  



具体方法`skip(long)`概述:
- 不做讨论,详细的查看具体子类的重写实现逻辑;  
- 至于超级接口的实现逻辑,个人暂不知目的性;  

方法`mark`,`markSupport`,`reset`,`available`,`close`:  
- 采取的都是空方法的实现,涉及到返回值,返回的都是默认值;  
- 值得注意的是`mark`方法标记为`synchronized`方法,但要知道sync是没有继承性的.  
- 至于`close`方法的具体实现,应当遵循顶层接口的约定;  

#### 重载`read`方法源码阅读:  
`read(byte[], int, int)`方法:  
```java
public int read(byte b[], int off, int len) throws IOException {
    // step1:合法性校验
    // 1.1 判断byte数组参数b是否为null,若是抛出空指针异常.
    if (b == null) {
        throw new NullPointerException();
    // 1.2 判断off,len参数不能为负数,以及要读取的数组不能大于可读取的数组长度,
    // 否则抛出下标越界异常.  
    } else if (off < 0 || len < 0 || len > b.length - off) {
        throw new IndexOutOfBoundsException();
    // 1.3 检查len的参数是否为0,若是直接返回0.
    // 此处的0表示的是读取的字节数量,即表示没有读取字节.  
    } else if (len == 0) {
        return 0;
    }

    // step2:校验通过后,开始按照要求读取字节数组.
    // 2.1 先读取一个字节,赋值给本地int变量c.
    //    判断c是否为-1,若是直接返回-1,表示当前流中没有可读取的字节.
    int c = read();
    if (c == -1) {
        return -1;
    }
    // 2.2 若读取字节c不是负数,则将其赋值给b[off]  
    //    接收的参数b[]表示接收读取字节的容器;
    //    接收的off,表示接收的开始下标,len表示要读取的长度
    b[off] = (byte)c;
    // 2.3 定义本地变量,初始为1,表示读取的字节数量.
    int i = 1;
    try {
        // 开始循环读取,阀值是参数len,读取成功一次,i+1
        for (; i < len ; i++) {
            c = read();
            // 若读取失败,结束循环
            if (c == -1) {
                break;
            }
            // 读取成功,存储读取的字节
            b[off + i] = (byte)c;
        }
    } catch (IOException ee) {
    }
    // 2.4 返回读取本地变量i
    return i;
}
```  
