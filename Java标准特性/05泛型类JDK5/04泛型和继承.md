泛型类和继承机制存在以下三点总结:  
- 类型参数之间的继承关系和泛型类之间没有任何关系.  
  - 比如以下语句:  
  - `Generic<Sup> supIns = new Generic<>();`  
  - `Generic<Sub> subIns = new Generic<>():`  
  - `supIns`和`subIns`之间无继承关系,它们只是泛型类`Generic<T>`的两个实例.  
  - `Sup`和`Sub`之间是存在继承关系的.  
- 参数化的泛型类实例,支持类型转换为原始类型的泛型类,但存在诸多限制.  
  - 假设条件:类的定义为:`class Sup{}`,`class Sub extends Sup{}`,`Generic<T extends Sup>`,  
  - 有构建语句:`Generic<Sub> subIns = new Generic<>();`  
  - 这种操作是不合法的:`Generic<Sup> supIns = subIns;`,会报出编译错误.  
  - 以下两种操作是支持的,但会产生限制:  
  - `Generic generic = subIns;`,会产生警告信息,虽然访问器和更改器支持调用,但实际调用的类型是`Object`,而不再是限定的`Sub`.  
  - `Geneirc<?> generic = subIns;`,虽然不会产生警告信息,但更改器的调用会直接拒绝,至于访问器的调用永远返回的是`Object`类型.  
- 泛型类之间,甚至和常规类,是支持扩展的,即继承和实现的方式.  
  - 比如以下的定义是合法的:  
  - `class Generic<T>{}`  
  - `interface Intef<T>{}`  
  - `class A<S> extends Generic<String> implements Intef<Object>{}`  
