关于状态的描述正确的方式是查看`java.lang.Thread$State`的API描述,部分总结有所错误,待定...  
关于`LockSupport`的方法.  

---

状态概览  
```java
Compiled from "Thread.java"
public final class java.lang.Thread$State extends java.lang.Enum<java.lang.Thread$State> {
  public static final java.lang.Thread$State NEW;
  public static final java.lang.Thread$State RUNNABLE;
  public static final java.lang.Thread$State BLOCKED;
  public static final java.lang.Thread$State WAITING;
  public static final java.lang.Thread$State TIMED_WAITING;
  public static final java.lang.Thread$State TERMINATED;
  public static java.lang.Thread$State[] values();
  public static java.lang.Thread$State valueOf(java.lang.String);
  static {};
}
```  

---  

`NEW`状态:使用new创建Thread的实例,但没有调用`start()`的线程,被定义为新建状态.  
```java
public class App {  
    public static void main(String[] args) {  
        Thread thread = new Thread();  
        System.out.println(thread.getState());// out:NEW  
    }  
}  
```  
---

`RUNNABLE`状态:创建Thread实例,并调用`start()`方法的线程,被定义为可运行状态.  
注意!可运行状态的线程,可能正在运行,也可能不在运行.  
```java
package ocn.axy.run;  
public class App {  
    public static void main(String[] args) {  
        Thread thread = new Thread();  
        thread.start();  
        System.out.println(thread.getState());// out:RUNNABLE  
    }  
}  
```  

---

`TERMINATED`状态:执行结束的线程,被定义为死亡状态.这里有两种场景:  
- `run()`方法正常结束,而正常死亡的线程.  
- 因未捕获的异常终止`run()`方法,而导致线程意外死亡的线程.  

测试正常死亡的线程:  
```java
package ocn.axy.run;
public class App {
	public static void main(String[] args) throws InterruptedException {
		Thread thread = new Thread();
		thread.start();
		thread.join(0);
		System.out.println(thread.getState());// out:TERMINATED
	}
}
```  
测试意外死亡的线程:  
```java
package ocn.axy.run;
public class App {
	public static void main(String[] args) throws InterruptedException {
		@SuppressWarnings("deprecation")
		Thread thread = new Thread(() -> {
			try {
				Thread.currentThread().stop();
			} catch (ThreadDeath e) {
				System.out.println(e);// out:java.lang.ThreadDeath
			}
		});
		thread.start();
		thread.join(0);
		System.out.println(thread.getState());// out:TERMINATED
	}
}
```  

---

`BLOCKED`状态:当线程试图获取内部对象锁时,尝试获取的期间被定义为阻塞状态.(注意!对象的内部锁即为sync锁)  
首次或之再次请求持有sync锁的时候,线程都处于阻塞的状态.比如假设调用`Object.wait()`方法,中间会有一个转换的过程,即等待状态转换阻塞状态.  
首次请求持有内部对象锁(sync):  
```java
package ocn.axy.run;
public class App {
	public static void main(String[] args) throws InterruptedException {
		Plan plan = new Plan();
		Thread t1 = new Thread(() -> plan.m1());
		Thread t2 = new Thread(() -> plan.m2());
		t1.start();
		Thread.sleep(500);
		t2.start();
		Thread.sleep(500);
		System.out.println(t2.getState()); // out:BLOCKED
	}
}
class Plan {
	public void m1() {
		synchronized (this.getClass()) {
			try {
				Thread.sleep(5_000);
			} catch (InterruptedException e) {}
		}
	}
	public void m2() {
		synchronized (this.getClass()) {
			System.out.println("enter-monitor");
		}
	}
}
```  
再次请求持有内部对象锁(sync锁):  
```java
package ocn.axy.run;
public class App {
	public static void main(String[] args) throws InterruptedException {
		Plan plan = new Plan();
		Thread t1 = new Thread(() -> plan.m1());
		Thread t2 = new Thread(() -> plan.m2());
		t1.start();
		Thread.sleep(500);
		t2.start();
		Thread.sleep(2_000);
		System.out.println(t1.getState()); // out:WAITING
		Thread.sleep(5_000);
		System.out.println(t1.getState());// out:BLOCKED
	}
}
class Plan {
	public void m1() {
		synchronized (this) {
			try {
				Thread.sleep(1_000);
				wait();
				System.out.println("reenter-monitor");
				for (;;) {}
			} catch (InterruptedException e) {}
		}
	}
	public void m2() {
		synchronized (this) {
			try {
				Thread.sleep(2_000);
				notifyAll();
				Thread.sleep(10_000);
			} catch (InterruptedException e) {}
		}
	}
}
```  
